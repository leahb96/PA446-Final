---
title: "PA 446 Final Project"
author: "Leah Berti"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
params:
  select_borough: Bronx
---

### Overview

Congestion pricing is a good idea if it targets people who can comfortably 
afford to pay. However, for a variety of reasons, many people who cannot 
comfortably afford tolls and fees commute by driving.

In this project, I will create an interactive map showing the percent of people 
in New York City's Census tracts who earn below different thresholds who drive 
alone to work. This map could serve as a starting point for city planners to 
better understand where lower income people tend to drive more and why (e.g. 
high violent crime rates, lack of sanitation and maintenance, unreliable transit
service, lack of transit access and active transportation infrastructure, etc.)
despite transit being less costly per trip.

### Set-up

Here are the necessary packages for this project:

```{r}
library(tidyverse) # basic data manipulation & visualization
library(naniar) # handling missing data
library(tidycensus) # to access U.S. Census data
library(shiny) # interactive website building
library(usethis) # GitHub version control
library(httr) # accessing APIs
library(jsonlite) # parsing API data
library(rpart) # for decision tree
library(rpart.plot) # for visualizing decision tree
library(parsnip) # ML model fitting
library(workflows) # bundles pre-processing & modelling
```

Here's my Census API setup:

```{r}
readRenviron("~/.Renviron") # calling Census API key

census_data23 <- load_variables(2023, # for 2023
                                "acs5", # 5-year estimates
                                cache = TRUE) # cache-ing for later access

nyc_transport_earnings <- get_acs(geography = "tract", # tract-level data
                                  # Means of transportation to work by worker's 
                                  # earnings in the past 12 months
                                  variables = c(
                                    "B08119_001", # all commuters
                                    "B08119_010", # Total: Car, truck or van - 
                                                  # drove alone
                                    # Subsets of drove-alone counts by income 
                                    # bracket
                                    "B08119_011", # $1 - $9,999
                                    "B08119_012", # $10,000 - $14,999
                                    "B08119_013", # $15,000 - $24,999
                                    "B08119_014", # $25,000 - $34,999
                                    "B08119_015", # $35,000 - $49,999
                                    "B08119_016", # $50,000 - $64,999
                                    "B08119_017", # $65,000 - $74,999
                                    "B08119_018", # 75,000 or more
                                    "B25024_001", # total housing units
                                    "B25024_002"), # single-family detached
                                  state = "NY",
                                  county = c("New York", # Manhattan
                                             "Kings", # Brooklyn
                                             "Queens", # Queens
                                             "Bronx", # the Bronx
                                             "Richmond"), # Staten Island
                                  year = 2023,
                                  survey = "acs5",
                                  geometry = TRUE) # for mapping
```

### Missing data

```{r}
# Counts and rates of missingness
miss_var_summary(nyc_transport_earnings)

# Fortunately, there is no missing data here.
```

In less favorable situations we could create a binary variable for blank, N/A, 
or otherwise coded for missing values and graph them using a histogram to see 
how missing-ness changes across values of particular x values.


### Cleaned up, intuitive borough labels 

```{r}
# Adding borough column
nyc_transport_earnings <- nyc_transport_earnings %>%
  mutate( # adding columns
    Borough = case_when( # borough name
      str_detect(NAME, "Bronx") ~ "Bronx",
      str_detect(NAME, "Richmond") ~ "Staten Island",
      str_detect(NAME, "Kings") ~ "Brooklyn",
      str_detect(NAME, "Queens") ~ "Queens",
      str_detect(NAME, "New York County") ~ "Manhattan")
  )

#checking results
unique(nyc_transport_earnings$Borough)
```

# New table: Count of driving commuters who earn up to $__k by tract

```{r}
pivot <- nyc_transport_earnings %>%
  # variables to keep
  select(GEOID, # tract ID
         Borough, # borough
         geometry, # for mapping
         variable, # variable code
         estimate) %>% # count of commuters
  # Change unit of analysis from estimate to tract
  pivot_wider(
    names_from = variable, # Unique income categories populating the old table's
    # 'variable' column become columns in the new table. 
    values_from = estimate) # populated w/ corresponding 'estimate' count

# New columns: For each tract, there were __ commuters who earned __.
nyc_drivers <- pivot %>% 
  mutate(
    under_25k = B08119_011 + B08119_012 + B08119_013, # <$25k
    under_50k = under_25k + B08119_014 + B08119_015, # $25k-$49,999
    under_75k = under_50k + B08119_016 + B08119_017, # $45k-$74,999 
    pct_drive = round(B08119_010 / B08119_001, 3),
    of_drivers_u25 = round(under_25k / B08119_010, 3),
    of_drivers_u50 = round(under_50k / B08119_010, 3),
    of_drivers_u75 = round(under_75k / B08119_010, 3),
    of_drivers_o75 = round(B08119_018 / B08119_010, 3),
    pct_detached_sf = round(B25024_002 / B25024_001, 3) 
  )

# Okay, the data seems to be in good shape. 
```

### Summary stats & Visualizations

Here's a basic choropleth map illustrating the percent of New York workers who 
commute by driving alone.

```{r}
ggplot(nyc_drivers, 
       aes(fill = pct_drive)) + geom_sf() +
  theme_minimal()
```


For "big-picture" borough-level insights, I aggregated borough data.

```{r}
# Count of NYC commuters who drive alone by borough 
# Broken down by income bracket 
borough_counts <- nyc_drivers %>%
  select(Borough, B08119_011:B08119_018) %>%
  sf::st_drop_geometry() %>% # -geometry doesn't work
  group_by(Borough) %>%
  summarise(
    u25 = sum(B08119_011 + B08119_012 + B08119_013), # under $25k
    o25_u50 = sum(B08119_014 + B08119_015), # $25k-$50k
    o50_u75 = sum(B08119_016 + B08119_017), # $50k-$75k
    o75 = sum(B08119_018) # over $75k
  )
```

I then made a couple of stacked bar charts with insights from the new table.

```{r}
# Pivoting so the unit of observation is borough-income bracket 
borough_ct_long <- borough_counts %>%
  pivot_longer(
    cols = u25:o75,
    names_to = "income",
    values_to = "count"
  )

# Count of NYC Drivers by Income Bracket & Stylized by Borough of Residence
ggplot(borough_ct_long, 
       aes(fill = Borough, 
           y = count, 
           x = income)) + 
    geom_bar(
      position = "stack", 
      stat="identity") +
  labs(title = "Count of NYC Drivers by Income Bracket",
       subtitle = "Stylized by Borough of Residence")

# Count of NYC Drivers by Borough & Stylized by Income Bracket
ggplot(borough_ct_long, 
       aes(fill = income, 
           y = count, 
           x = Borough)) + 
    geom_bar(
      position = "stack", 
      stat="identity") +
  labs(title = "Count of NYC Drivers by Borough",
       subtitle = "Stylized by Income Bracket")
```

I also made a simple parameterized report that can be customized by editing the 
YAML where it says "select_borough."

For this, I calculated the percent of commuters who drive in each borough. 

```{r}
drivers_pct_borough <- nyc_drivers %>%
  select(Borough, B08119_001, B08119_010) %>%
  sf::st_drop_geometry() %>%
  group_by(Borough) %>%
  summarize(
    commuters = sum(B08119_001),
    drivers = sum(B08119_010)
    )

drivers_pct_borough <- drivers_pct_borough %>%
  mutate(pct_drive = drivers / commuters)
```

The simple report shows counts of total commuters, commuters who drive alone, 
and commuters who fall within each income bracket, along with drivers as a 
percent of all commuters, for the selected borough.

```{r}
# Total commuters
print(
  drivers_pct_borough %>%
  filter(Borough == params$select_borough)
)

print(
  borough_counts %>%
    filter(Borough == params$select_borough)
)
```

### Shiny web app
**Counts and percents of commuters who drive alone by income threshold**

For this part, I took some help from Kyle Walker's *Mapping Census Data with R*, 
specifically, Section 6.6.3: "Reactive mapping with Shiny," although I opted to 
use geom_sf instead of leaflet.

First, I need to create some categories to select from.
```{r}
# creating categories to reference 
thresholds <- c("Percent of Commuters who Drive Alone" = "pct_drive",
              "Percent of Housing Units: Single-Family, Detached" = "pct_detached_sf",
              "Count of Drivers Under $25k" = "under_25k",
              "Count of Drivers Under $50k" = "under_50k",
              "Count of Drivers Under $75k" = "under_75k",
              "Count of Drivers Over $75k" = "B08119_018",
              "Drivers Under $25k as % of Drivers" = "of_drivers_u25",
              "Drivers Under $50k as % of Drivers" = "of_drivers_u50",
              "Drivers Under $75k as % of Drivers" = "of_drivers_u75",
              "Drivers Over $75k as % of Drivers" = "of_drivers_o75")
```

Now I can run the actual app.
```{r}
# Setting up user interface
ui <- fluidPage(
  titlePanel("New Yorkers who drive to work alone by income"),

  sidebarLayout(
    sidebarPanel(
      selectInput(
        inputId = "var",
        label   = "I would like to know more about:",
        choices = thresholds,
        selected = "pct_drive"
      )
    ),
    mainPanel(
      plotOutput("map", height = 600)
    )
  )
)

# Establishing server connection
server <- function(input, output, session) {

# Interactive content to display  
  output$map <- renderPlot({
    ggplot(nyc_drivers) +
      geom_sf(aes(fill = .data[[input$var]]), color = NA) +
      scale_fill_viridis_c(option = "magma", na.value = "grey90") +
      theme_minimal() +
      labs(fill = names(thresholds)[thresholds == input$var])
  })
}

shinyApp(ui, server)
```

### Decision tree

**What is the relationship between the percent of people earning under $50k and driving as a primary mode of commuting?**

If you saw some housing data being pulled in at the beginning and wondered what
it was for, you're about to find out.

I'm going to run a decision tree that uses the following variables to predict
the percent of people who drive to work in a given tract:

- Borough
- Percent of workers who earn less than $50k/year
- Percent of housing units that are single-family detached

The binary outcome I'm interested in is whether more than one in five commuters 
drives to work in each tract.

First, I need to do some extra data preparation.
```{r}
# There were some undefined values in tracts with no commuters (e.g. those which
# are entirely industrial), so I'm going to omit those from my calculation.

undefined_removed <- na.omit(nyc_drivers)

# Let's see what the city-wide median rate of driving alone is by tract among
# commuters. This method isn't perfect, but we don't have individual data, so 
# this will have to do.

print(
  median(undefined_removed$pct_drive)
)

# I'm also curious about how these values are distributed, though that's not
# super relevant to this section. 
ggplot(undefined_removed, 
       aes(y = pct_drive)) + 
  geom_boxplot()

# Adding binary indicator of a tract's car dependency
undefined_removed <- undefined_removed %>%
  mutate(
    car_dependent = case_when(
      pct_drive > 0.22 ~ "1",
      pct_drive <= 0.22 ~ "0"
    )
  )
```


Next, I'll build the model.

```{r}
tree_spec <- decision_tree(
  tree_depth = 5, # up to 5 iterations of “if/else” questions 
  cost_complexity = 0) %>% # no auto-pruning
  set_engine("rpart") %>% # standard R engine
  set_mode("classification") 

tree_fit <- workflow() %>% # containing "recipe" and model
  add_model(tree_spec) %>% # the model to contain
  add_formula( # what we want to know and how 
    as.factor(car_dependent) ~ # Outcome of interest: Pct. who drive alone
      Borough + # by the borough in which a tract is located
      of_drivers_u50 + # percent of drivers who earn less than $50k
      pct_detached_sf) %>% # based on these variables
  fit(data = undefined_removed) # data source

simple_tree <- tree_fit %>% # fitted model, model specs, and preprocessing info
  extract_fit_parsnip() %>% # creating core model object
  pluck("fit") # extracting elements
```


Finally, I'll visualize the model.

```{r}
# These lines format the margins.
op <- par(no.readonly = TRUE) 
on.exit(par(op), add = TRUE) 
par(mar = c(4, 4, 2, 1))  

# Drawing the flowchart
rpart.plot(
  simple_tree, # model/specs/preprocessing info from Line 92
  type = 3,        # boxes + labels
  extra = 104,     # predicted class + probabilities
  fallen.leaves = TRUE, # so terminal nodes line up neatly
  #roundint = FALSE, #prevents the warning
  main = "Predicting a Tract's Car Dependence" # title
)
```

The model first splits tracts where fewer than 7 percent of homes are single-
family detached from all other tracts. From the branch of tracts where 
single-family detached homes represent fewer than 7 percent of all units, tracts
are split again between those in Manhattan and those in NYC's other four 
boroughs. The terminal "leaf" at the end of the Manhattan branch shows that 
there is a 99% probability that a given tract in Manhattan is not car dependent 
(denoted by the zero at the top of the leaf) and a 1% chance that it is. The 13%
at the bottom of the leaf indicates the error rate - i.e. 13% of tracts in this 
leaf that were classified as not car-dependent actually were car-dependent.

Remaining branches and leaves can be interpreted similarly. Broadly, we can see
that tracts in Manhattan and where there are higher proportions of multifamily
and attached single-family housing (there's definitely some confounding bias 
here, since Manhattan is densely-developed) tend to have lower rates of car 
dependence. While the role of driving commuters' incomes isn't too clear in 
denser areas (like much of Manhattan), it becomes more pronounced when we look 
at the outer boroughs and less-dense areas with more detached single family
homes in general.
