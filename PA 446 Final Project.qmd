---
title: "PA 446 Final Project"
author: "Leah Berti"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
params:
  select_borough: Bronx
---

### Overview

Congestion pricing is a good idea if it targets people who can comfortably 
afford to pay. However, for a variety of reasons, many people who cannot 
comfortably afford tolls and fees commute by driving.

In this project, I will create an interactive map showing the percent of people 
in New York City's Census tracts who earn below different thresholds who drive 
alone to work. This map could serve as a starting point for city planners to 
better understand where lower income people tend to drive more and why (e.g. 
high violent crime rates, lack of sanitation and maintenance, unreliable transit
service, lack of transit access and active transportation infrastructure, etc.)
despite transit being less costly per trip.

### Set-up

Here are the necessary packages for this project:

```{r}
library(tidyverse) # basic data manipulation & visualization
library(naniar) # handling missing data
library(tidycensus) # to access U.S. Census data
library(shiny) # interactive website building
library(usethis) # GitHub version control
library(httr) # accessing APIs
library(jsonlite) # parsing API data
library(rpart) # for decision tree
library(rpart.plot) # for visualizing decision tree
library(parsnip) # ML model fitting
library(workflows) # bundles pre-processing & modelling
```

Here's my Census API setup:

```{r}
readRenviron("~/.Renviron") # calling Census API key

census_data23 <- load_variables(2023, # for 2023
                                "acs5", # 5-year estimates
                                cache = TRUE) # cache-ing for later access

nyc_transport_earnings <- get_acs(geography = "tract", # tract-level data
                                  # Means of transportation to work by worker's 
                                  # earnings in the past 12 months
                                  variables = c(
                                    "B08119_001", # all commuters
                                    "B08119_010", # Total: Car, truck or van - 
                                                  # drove alone
                                    # Subsets of drove-alone counts by income 
                                    # bracket
                                    "B08119_011", # $1 - $9,999
                                    "B08119_012", # $10,000 - $14,999
                                    "B08119_013", # $15,000 - $24,999
                                    "B08119_014", # $25,000 - $34,999
                                    "B08119_015", # $35,000 - $49,999
                                    "B08119_016", # $50,000 - $64,999
                                    "B08119_017", # $65,000 - $74,999
                                    "B08119_018", # 75,000 or more
                                    "B25024_001", # total housing units
                                    "B25024_002"), # single-family detached
                                  state = "NY",
                                  county = c("New York", # Manhattan
                                             "Kings", # Brooklyn
                                             "Queens", # Queens
                                             "Bronx", # the Bronx
                                             "Richmond"), # Staten Island
                                  year = 2023,
                                  survey = "acs5",
                                  geometry = TRUE) # for mapping
```

### Missing data

```{r}
# Counts and rates of missingness
miss_var_summary(nyc_transport_earnings)

# Fortunately, there is no missing data here.
```

In less favorable situations we could create a binary variable for blank, N/A, 
or otherwise coded for missing values and graph them using a histogram to see 
how missing-ness changes across values of particular x values.


### Cleaned up, intuitive borough labels 

```{r}
# Adding borough column
nyc_transport_earnings <- nyc_transport_earnings %>%
  mutate( # adding columns
    Borough = case_when( # borough name
      str_detect(NAME, "Bronx") ~ "Bronx",
      str_detect(NAME, "Richmond") ~ "Staten Island",
      str_detect(NAME, "Kings") ~ "Brooklyn",
      str_detect(NAME, "Queens") ~ "Queens",
      str_detect(NAME, "New York County") ~ "Manhattan")
  )

#checking results
unique(nyc_transport_earnings$Borough)
```

# New table: Count of driving commuters who earn up to $__k by tract

```{r}
pivot <- nyc_transport_earnings %>%
  # variables to keep
  select(GEOID, # tract ID
         Borough, # borough
         geometry, # for mapping
         variable, # variable code
         estimate) %>% # count of commuters
  # Change unit of analysis from estimate to tract
  pivot_wider(
    names_from = variable, # Unique income categories populating the old table's
    # 'variable' column become columns in the new table. 
    values_from = estimate) # populated w/ corresponding 'estimate' count

# New columns: For each tract, there were __ commuters who earned __.
nyc_drivers <- pivot %>% 
  mutate(
    under_25k = B08119_011 + B08119_012 + B08119_013, # <$25k
    under_50k = under_25k + B08119_014 + B08119_015, # $25k-$49,999
    under_75k = under_50k + B08119_016 + B08119_017, # $45k-$74,999 
    pct_drive = round(B08119_010 / B08119_001, 3),
    of_drivers_u25 = round(under_25k / B08119_010, 3),
    of_drivers_u50 = round(under_50k / B08119_010, 3),
    of_drivers_u75 = round(under_75k / B08119_010, 3),
    of_drivers_o75 = round(B08119_018 / B08119_010, 3),
    pct_detached_sf = round(B25024_002 / B25024_001, 3) 
  )

# Okay, the data seems to be in good shape. 
```

### Summary stats & Visualizations

Here's a basic choropleth map illustrating the percent of New York workers who 
commute by driving alone.

```{r}
ggplot(nyc_drivers, 
       aes(fill = pct_drive)) + geom_sf() +
  theme_minimal()
```


For "big-picture" borough-level insights, I aggregated borough data.

```{r}
# Count of NYC commuters who drive alone by borough 
# Broken down by income bracket 
borough_counts <- nyc_drivers %>%
  select(Borough, B08119_011:B08119_018) %>%
  sf::st_drop_geometry() %>% # -geometry doesn't work
  group_by(Borough) %>%
  summarise(
    u25 = sum(B08119_011 + B08119_012 + B08119_013), # under $25k
    o25_u50 = sum(B08119_014 + B08119_015), # $25k-$50k
    o50_u75 = sum(B08119_016 + B08119_017), # $50k-$75k
    o75 = sum(B08119_018) # over $75k
  )
```

I then made a couple of stacked bar charts with insights from the new table.

```{r}
# Pivoting so the unit of observation is borough-income bracket 
borough_ct_long <- borough_counts %>%
  pivot_longer(
    cols = u25:o75,
    names_to = "income",
    values_to = "count"
  )

# Count of NYC Drivers by Income Bracket & Stylized by Borough of Residence
ggplot(borough_ct_long, 
       aes(fill = Borough, 
           y = count, 
           x = income)) + 
    geom_bar(
      position = "stack", 
      stat="identity") +
  labs(title = "Count of NYC Drivers by Income Bracket",
       subtitle = "Stylized by Borough of Residence")

# Count of NYC Drivers by Borough & Stylized by Income Bracket
ggplot(borough_ct_long, 
       aes(fill = income, 
           y = count, 
           x = Borough)) + 
    geom_bar(
      position = "stack", 
      stat="identity") +
  labs(title = "Count of NYC Drivers by Borough",
       subtitle = "Stylized by Income Bracket")
```

I also made a simple parameterized report that can be customized by editing the 
YAML where it says "select_borough."

For this, I calculated the percent of commuters who drive in each borough. 

```{r}
drivers_pct_borough <- nyc_drivers %>%
  select(Borough, B08119_001, B08119_010) %>%
  sf::st_drop_geometry() %>%
  group_by(Borough) %>%
  summarize(
    commuters = sum(B08119_001),
    drivers = sum(B08119_010)
    )

drivers_pct_borough <- drivers_pct_borough %>%
  mutate(pct_drive = drivers / commuters)
```

